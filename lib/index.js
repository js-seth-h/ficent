// Generated by CoffeeScript 1.7.1
var cutFlowsByArity, debug, exports, flyway, joinAsyncFns, runChain, runFlow, runForkChain, runForkFlow, runReduce, runSeries, _chain, _flow, _isArray, _isError, _map, _reduce, _retry, _series, _toString,
  __slice = [].slice,
  __hasProp = {}.hasOwnProperty;

debug = require('debug')('flyway');

_toString = Object.prototype.toString;

_isArray = Array.isArray || function(obj) {
  return _toString.call(obj) === "[object Array]";
};

_isError = function(obj) {
  return _toString.call(obj) === "[object Error]";
};

cutFlowsByArity = function(fnFlows, arity) {
  var fn, inx, _i, _len;
  for (inx = _i = 0, _len = fnFlows.length; _i < _len; inx = ++_i) {
    fn = fnFlows[inx];
    if (!_isArray(fn) && fn.length === arity) {
      return fnFlows.slice(inx);
    }
  }
  return [];
};

joinAsyncFns = function(fns, outCallback) {
  var checkJoin, errors, finished, fn, inx, l, results, _i, _j, _len, _results, _results1;
  l = fns.length;
  errors = (function() {
    _results = [];
    for (var _i = 0; 0 <= l ? _i < l : _i > l; 0 <= l ? _i++ : _i--){ _results.push(_i); }
    return _results;
  }).apply(this).map(function() {
    return void 0;
  });
  results = errors.map(function() {
    return void 0;
  });
  finished = errors.map(function() {
    return false;
  });
  checkJoin = function() {
    var error, errs;
    if (!finished.every(function(v) {
      return v;
    })) {
      return;
    }
    errs = errors.filter(function(err) {
      return err;
    });
    error = void 0;
    if (errs.length > 0) {
      error = errs[0];
      error.errors = errors;
    }
    return outCallback(error, results);
  };
  _results1 = [];
  for (inx = _j = 0, _len = fns.length; _j < _len; inx = ++_j) {
    fn = fns[inx];
    _results1.push((function(inx) {
      return fn(function() {
        var err, output;
        err = arguments[0], output = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
        if (output.length === 1) {
          output = output[0];
        }
        finished[inx] = true;
        results[inx] = output;
        errors[inx] = err;
        return checkJoin();
      });
    })(inx));
  }
  return _results1;
};

runForkFlow = function(fnFlows, args, outCallback) {
  var fns;
  fns = fnFlows.map(function(flow) {
    return function(next) {
      if (!_isArray(flow)) {
        flow = [flow];
      }
      return runFlow(flow, null, args, next);
    };
  });
  return joinAsyncFns(fns, outCallback);
};

runFlow = function(fnFlows, err, args, outCallback) {
  var argsToCall, errorHandlerArity, fn, fnArr, fns;
  errorHandlerArity = args.length + 2;
  if (err) {
    fnFlows = cutFlowsByArity(fnFlows, errorHandlerArity);
  }
  if (fnFlows.length === 0) {
    return outCallback.apply(null, [err].concat(__slice.call(args)));
  }
  fn = fnFlows[0], fns = 2 <= fnFlows.length ? __slice.call(fnFlows, 1) : [];
  if (_isArray(fn)) {
    fnArr = fn;
    fn = function() {
      var args, next, _i;
      args = 2 <= arguments.length ? __slice.call(arguments, 0, _i = arguments.length - 1) : (_i = 0, []), next = arguments[_i++];
      return runForkFlow(fnArr, args, next);
    };
  }
  argsToCall = args;
  if (fn.length === errorHandlerArity) {
    argsToCall = [err].concat(args);
  }
  return fn.apply(null, __slice.call(argsToCall).concat([function(err) {
    return runFlow(fns, err, args, outCallback);
  }]));
};

runForkChain = function(fnFlows, args, outCallback) {
  var fns;
  fns = fnFlows.map(function(flow) {
    return function(next) {
      if (!_isArray(flow)) {
        flow = [flow];
      }
      return runChain(flow, args, next);
    };
  });
  return joinAsyncFns(fns, outCallback);
};

runChain = function(fnFlows, args, outCallback) {
  var fn, fnArr, fns;
  debug('runChain', fnFlows, args);
  fn = fnFlows[0], fns = 2 <= fnFlows.length ? __slice.call(fnFlows, 1) : [];
  if (_isArray(fn)) {
    fnArr = fn;
    fn = function() {
      var args, next, _i;
      args = 2 <= arguments.length ? __slice.call(arguments, 0, _i = arguments.length - 1) : (_i = 0, []), next = arguments[_i++];
      return runForkChain(fnArr, args, next);
    };
  }
  return fn.apply(null, __slice.call(args).concat([function() {
    var err, output;
    err = arguments[0], output = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
    if (err) {
      return outCallback(err);
    }
    if (fns.length === 0) {
      return outCallback.apply(null, [null].concat(__slice.call(output)));
    }
    return runChain(fns, output, outCallback);
  }]));
};

runReduce = function(data, fn, memo, outCallback) {
  var head, others;
  if (data.length === 0) {
    return outCallback(null, memo);
  }
  head = data[0], others = 2 <= data.length ? __slice.call(data, 1) : [];
  return fn(memo, head, function(err, newMemo) {
    if (err) {
      return outCallback(err);
    }
    return runReduce(others, fn, newMemo, outCallback);
  });
};

runSeries = function(data, fn, results, outCallback) {
  var head, others;
  if (data.length === 0) {
    return outCallback(null, results);
  }
  head = data[0], others = 2 <= data.length ? __slice.call(data, 1) : [];
  return fn(head, function(err, output) {
    if (err) {
      return outCallback(err);
    }
    results.push(output);
    return runSeries(others, fn, results, outCallback);
  });
};

_series = function(fn) {
  return function(data, outCallback) {
    return runSeries(data, fn, [], outCallback);
  };
};

_map = function(fn) {
  return function(data, outCallback) {
    var fns, key, result, value, _fn;
    if (_isArray(data)) {
      fns = data.map(function(args) {
        if (!_isArray(args)) {
          args = [args];
        }
        return function(next) {
          return fn.apply(null, __slice.call(args).concat([next]));
        };
      });
      return joinAsyncFns(fns, outCallback);
    } else {
      fns = [];
      result = {};
      _fn = function(key, value) {
        return fns.push(function(next) {
          return fn(key, value, function() {
            var err, output;
            err = arguments[0], output = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
            if (output.length === 1) {
              output = output[0];
            }
            result[key] = output;
            return next.apply(null, [err].concat(__slice.call(output)));
          });
        });
      };
      for (key in data) {
        if (!__hasProp.call(data, key)) continue;
        value = data[key];
        _fn(key, value);
      }
      return joinAsyncFns(fns, function(err, results) {
        return outCallback(err, result);
      });
    }
  };
};

_reduce = function(memo, fn) {
  return function(data, outCallback) {
    return runReduce(data, fn, memo, outCallback);
  };
};

_retry = function(tryLimit, fn) {
  return function() {
    var args, argsToCall, fnDone, outCallback, tryCnt, _i;
    args = 2 <= arguments.length ? __slice.call(arguments, 0, _i = arguments.length - 1) : (_i = 0, []), outCallback = arguments[_i++];
    tryCnt = 0;
    fnDone = function() {
      var err, output;
      err = arguments[0], output = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
      tryCnt++;
      if (err && tryCnt < tryLimit) {
        return fn.apply(null, argsToCall);
      } else {
        return outCallback.apply(null, [err].concat(__slice.call(output)));
      }
    };
    argsToCall = args.concat(fnDone);
    return fn.apply(null, argsToCall);
  };
};

_chain = function(chainFns) {
  return function() {
    var args, outCallback, _i;
    args = 2 <= arguments.length ? __slice.call(arguments, 0, _i = arguments.length - 1) : (_i = 0, []), outCallback = arguments[_i++];
    if (typeof outCallback !== 'function') {
      args.push(outCallback);
      outCallback = function() {};
    }
    return runChain(chainFns, args, outCallback);
  };
};

_flow = function(flowFns) {
  return function() {
    var args, err, first, outCallback, _i;
    args = 2 <= arguments.length ? __slice.call(arguments, 0, _i = arguments.length - 1) : (_i = 0, []), outCallback = arguments[_i++];
    first = args[0];
    err = null;
    if (first === null || first === void 0 || _isError(first)) {
      err = args.shift();
    }
    if (typeof outCallback !== 'function') {
      args.push(outCallback);
      outCallback = function() {};
    }
    return runFlow(flowFns, err, args, outCallback);
  };
};

_flow.run = function() {
  var args, fnFlows, _i;
  args = 2 <= arguments.length ? __slice.call(arguments, 0, _i = arguments.length - 1) : (_i = 0, []), fnFlows = arguments[_i++];
  return _flow(fnFlows).apply(null, args);
};

_chain.run = function() {
  var args, fnFlows, _i;
  args = 2 <= arguments.length ? __slice.call(arguments, 0, _i = arguments.length - 1) : (_i = 0, []), fnFlows = arguments[_i++];
  return _chain(fnFlows).apply(null, args);
};

flyway = _flow;

flyway.fn = {};

flyway.makeFn = {};

flyway.flow = _flow;

flyway.chain = _chain;

flyway.map = _map;

flyway.each = _map;

flyway.reduce = _reduce;

flyway.retry = _retry;

flyway.series = _series;

module.exports = exports = flyway;
